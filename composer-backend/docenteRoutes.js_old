const express = require('express');
const jwt = require('jsonwebtoken');
const speakeasy = require('speakeasy');
const { generateQuestionsWithAI } = require('./ai');
const requireDocente = require('./middlewares/requireDocente');

module.exports = (prisma, transporter) => {
  const router = express.Router();

  // Request OTP for Docente Login
  router.post('/docentes/request-otp', async (req, res) => {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ message: 'Email is required' });
    }

    try {
      let docente = await prisma.docente.findUnique({ where: { email } });

      if (!docente) {
        docente = await prisma.docente.create({
          data: {
            email,
            nombre: email.split('@')[0],
            apellido: 'Docente',
            otpEnabled: false,
          },
        });
      }

      const secret = speakeasy.generateSecret({ length: 20 }).base32;
      const otp = speakeasy.totp({
        secret: secret,
        encoding: 'base32',
        step: 300, // OTP valid for 5 minutes
      });

      await prisma.docente.update({
        where: { id: docente.id },
        data: {
          otpSecret: secret,
          otpEnabled: true,
        },
      });

      const mailOptions = {
        from: `"HMPY (Historia de la Música PY - Academia)" <${process.env.EMAIL_USER}>`,
        to: email,
        subject: 'Tu código OTP para iniciar sesión como Docente en HMPY',
        html: `
          <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #ffffff; background-color: #1a202c; padding: 20px;">
            <div style="max-width: 600px; margin: 0 auto; background-color: #2d3748; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
              <h2 style="color: #9f7aea; text-align: center;">Tu Código de Verificación (OTP) para Docentes</h2>
              <p style="color: #e2e8f0;">Tu código de un solo uso (OTP) para iniciar sesión en el portal de docentes de HMPY es:</p>
              <p style="font-size: 24px; font-weight: bold; text-align: center; color: #667eea; background-color: #4a5568; padding: 10px; border-radius: 4px;">${otp}</p>
              <p style="color: #e2e8f0;">Este código es válido por 5 minutos. Por favor, no lo compartas con nadie.</p>
              <p style="color: #e2e8f0;">Si no solicitaste este código, por favor ignora este correo electrónico.</p>
              <p style="color: #cbd5e0; font-size: 0.9em; text-align: center; margin-top: 20px;">Atentamente, El Equipo de HMPY</p>
            </div>
          </div>
        `,
      };

      await transporter.sendMail(mailOptions);
      res.status(200).json({ message: 'OTP sent to email' });

    } catch (error) {
      console.error('Error requesting docente OTP:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  });

  // Verify OTP and Login Docente
  router.post('/docentes/verify-otp', async (req, res) => {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({ message: 'Email and OTP are required' });
    }

    try {
      const docente = await prisma.docente.findUnique({ where: { email } });

      if (!docente || !docente.otpSecret || !docente.otpEnabled) {
        return res.status(401).json({ message: 'Invalid email or OTP not requested' });
      }

      const tokenValidates = speakeasy.totp.verify({
        secret: docente.otpSecret,
        encoding: 'base32',
        token: otp,
        window: 1, // Allow a 30-second leeway
        step: 300,
      });

      if (!tokenValidates) {
        return res.status(401).json({ message: 'Invalid OTP' });
      }

      // OTP is valid, generate JWT
      const jwtToken = jwt.sign(
        { docenteId: docente.id, email: docente.email, role: 'docente' },
        process.env.JWT_SECRET,
        { expiresIn: '1h' } // Token expires in 1 hour
      );

      res.status(200).json({ message: 'Login successful', token: jwtToken, docente });

    } catch (error) {
      console.error('Error verifying docente OTP:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  });

  // Get catedras assigned to the logged-in docente
  router.get('/docentes/me/catedras', requireDocente, async (req, res) => {
    try {
      const docenteId = req.docente.docenteId;

      const catedras = await prisma.catedra.findMany({
        where: { docenteId: docenteId },
        include: {
          evaluaciones: true,
          tareasMaestras: {
            include: {
              _count: {
                select: { asignaciones: true }
              }
            }
          }, // Incluir conteo de asignaciones
          alumnos: {
            include: {
              alumno: true,
              composer: true,
            },
          },
        },
      });
      res.status(200).json(catedras);
    } catch (error) {
      console.error('Error fetching docente catedras:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  });

  // Get a specific catedra for the logged-in docente
  router.get('/docentes/me/catedras/:id', requireDocente, async (req, res) => {
    try {
      const docenteId = req.docente.docenteId;
      const catedraId = parseInt(req.params.id);

      const catedra = await prisma.catedra.findUnique({
        where: { id: catedraId, docenteId: docenteId },
        include: {
          evaluaciones: true,
          tareasMaestras: {
            include: {
              asignaciones: true, // Incluir asignaciones para obtener su estado
            },
          }, 
          alumnos: {
            include: {
              alumno: true,
              composer: true,
            },
          },
          diasClase: { // Incluir la relación diasClase
            include: { asistencias: true }, // Incluir las asistencias de cada día de clase
          },
          horariosPorDia: true, // Incluir la nueva relación horariosPorDia
        },
      });

      if (!catedra) {
        return res.status(404).json({ message: 'Catedra not found or not assigned to this docente' });
      }
      res.status(200).json(catedra);
    } catch (error) {
      console.error('Error fetching specific docente catedra:', error);
      res.status(500).json({ message: 'Internal server error' });
    }
  });

  // GET /docentes/catedras/:catedraId/tareas-maestras - Obtener todas las tareas maestras de una cátedra
  router.get('/docentes/catedras/:catedraId/tareas-maestras', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const tareasMaestras = await prisma.tareaMaestra.findMany({
        where: {
          catedraId: parseInt(catedraId),
        },
        orderBy: {
          created_at: 'desc',
        },
      });

      res.status(200).json(tareasMaestras);
    } catch (error) {
      console.error('Error al obtener tareas maestras:', error);
      res.status(500).json({ error: 'Error al obtener las tareas maestras.', details: error.message });
    }
  });

  // GET /docentes/catedras/:catedraId/tareas-maestras/:tareaMaestraId - Obtener una tarea maestra específica de una cátedra
  router.get('/docentes/catedras/:catedraId/tareas-maestras/:tareaMaestraId', requireDocente, async (req, res) => {
    const { catedraId, tareaMaestraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const tareaMaestra = await prisma.tareaMaestra.findUnique({
        where: {
          id: parseInt(tareaMaestraId),
          catedraId: parseInt(catedraId),
        },
        include: {
          asignaciones: {
            select: {
              alumnoId: true,
            },
          },
        },
      });

      if (!tareaMaestra) {
        return res.status(404).json({ error: 'Tarea maestra no encontrada o no pertenece a esta cátedra.' });
      }

      res.status(200).json(tareaMaestra);
    } catch (error) {
      console.error('Error al obtener tarea maestra específica:', error);
      res.status(500).json({ error: 'Error al obtener la tarea maestra.', details: error.message });
    }
  });

  // Create a new master task for a catedra
  router.post('/docentes/catedras/:catedraId/tareas', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const { titulo, descripcion, puntos_posibles, fecha_entrega, recursos, multimedia_path } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      // Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        }
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra not found or access denied.' });
      }

      // Create the master task
      const newTareaMaestra = await prisma.tareaMaestra.create({
        data: {
          titulo,
          descripcion,
          puntos_posibles: parseInt(puntos_posibles),
          fecha_entrega: fecha_entrega ? new Date(fecha_entrega) : null,
          recursos,
          multimedia_path,
          catedra: { connect: { id: parseInt(catedraId) } },
        },
      });

      // Create a publicacion for the new master task in the catedra's board
      const publicacionTitle = `Nueva Tarea: ${titulo}`;
      const formattedFechaEntrega = fecha_entrega ? new Date(fecha_entrega).toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric' }) : 'No definida';

      const publicacionContent = `
  <p>Se ha creado una nueva tarea: <strong>${titulo}</strong>.</p>
  <p><strong>Descripción:</strong> ${descripcion || 'Sin descripción'}.</p>
  <p><strong>Fecha de Entrega:</strong> ${formattedFechaEntrega}.</p>
      `;

      const newPublicacion = await prisma.publicacion.create({
        data: {
          titulo: publicacionTitle,
          contenido: publicacionContent,
          tipo: 'TAREA',
          catedraId: parseInt(catedraId),
          autorDocenteId: docenteId,
          visibleToStudents: false, // Correctly set to false initially
          tareaMaestraId: newTareaMaestra.id, // Establish the crucial link here
        },
      });

      // Update the TareaMaestra with the publicacionId for the back-reference
      await prisma.tareaMaestra.update({
        where: { id: newTareaMaestra.id },
        data: { publicacionId: newPublicacion.id },
      });

      res.status(201).json({ message: 'Tarea maestra creada exitosamente. Ahora puedes asignarla a los alumnos.', tareaMaestra: newTareaMaestra });

    } catch (error) {
      console.error('Error creating master task for docente:', error);
      res.status(500).json({ error: 'Failed to create master task.', details: error.message });
    }
  });

  // New route to assign a master task to students
  router.post('/docentes/catedras/:catedraId/tareas-maestras/:tareaMaestraId/assign', requireDocente, async (req, res) => {
    const { catedraId, tareaMaestraId } = req.params;
    const { alumnoIds } = req.body; // Array of alumno IDs
    const docenteId = req.docente.docenteId;

    if (!Array.isArray(alumnoIds) || alumnoIds.length === 0) {
      return res.status(400).json({ error: 'Se requiere una lista de IDs de alumnos para asignar la tarea.' });
    }

    try {
      const tareaMaestra = await prisma.tareaMaestra.findUnique({
        where: { id: parseInt(tareaMaestraId) },
        include: {
          catedra: true,
          publicacion: true, // Incluir publicacion para obtener su ID
        },
      });

      if (!tareaMaestra) {
        return res.status(404).json({ error: 'Tarea maestra no encontrada.' });
      }

      if (tareaMaestra.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para asignar esta tarea maestra.' });
      }

      const assignedTasks = [];
      for (const alumnoId of alumnoIds) {
        const alumnoIdInt = parseInt(alumnoId);

        const alumno = await prisma.alumno.findUnique({ where: { id: alumnoIdInt } });
        if (!alumno) {
          console.warn(`Alumno con ID ${alumnoId} no encontrado. Saltando asignación.`);
          continue;
        }

        // Check if the student is actually enrolled in the catedra
        const enrollment = await prisma.catedraAlumno.findFirst({
          where: {
            catedraId: tareaMaestra.catedraId,
            alumnoId: alumnoIdInt,
          },
        });

        if (!enrollment) {
          console.warn(`Alumno ${alumnoId} no está inscrito en la cátedra ${tareaMaestra.catedraId}. Saltando asignación.`);
          continue;
        }

        const asignacion = await prisma.tareaAsignacion.upsert({
          where: {
            alumnoId_tareaMaestraId: {
              alumnoId: alumnoIdInt,
              tareaMaestraId: parseInt(tareaMaestraId),
            },
          },
          update: {},
          create: {
            alumnoId: alumnoIdInt,
            tareaMaestraId: parseInt(tareaMaestraId),
            estado: 'ASIGNADA', // Default state for new assignment
          },
        });
        assignedTasks.push(asignacion);

        // Send email notification to student
        if (alumno.email) {
          const mailOptions = {
            from: `"HMPY (Historia de la Música PY - Academia)" <${process.env.EMAIL_USER}>`,
            to: alumno.email,
            subject: `¡Nueva Tarea Asignada en ${tareaMaestra.catedra.nombre}!`,
            html: `
              <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #ffffff; background-color: #1a202c; padding: 20px;">
                <div style="max-width: 600px; margin: 0 auto; background-color: #2d3748; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
                  <h2 style="color: #9f7aea; text-align: center;">¡Hola ${alumno.nombre}!</h2>
                  <p style="color: #e2e8f0;">Tu docente ha asignado una nueva tarea para la cátedra de <strong>${tareaMaestra.catedra.nombre}</strong>.</p>
                  <p style="color: #e2e8f0;"><strong>Título de la Tarea:</strong> ${tareaMaestra.titulo}</p>
                  <p style="color: #e2e8f0;"><strong>Descripción:</strong> ${tareaMaestra.descripcion}</p>
                  <p style="color: #e2e8f0;"><strong>Fecha de Entrega:</strong> ${tareaMaestra.fecha_entrega ? new Date(tareaMaestra.fecha_entrega).toLocaleDateString() : 'N/A'}</p>
                  <p style="color: #e2e8f0;">Puedes ver los detalles y realizar tu entrega en la plataforma.</p>
                  <p style="color: #cbd5e0; font-size: 0.9em; text-align: center; margin-top: 20px;">Atentamente, El Equipo de HMPY</p>
                </div>
              </div>
            `,
          };
          try {
            await transporter.sendMail(mailOptions);
            console.log(`Task assignment notification email sent to ${alumno.email}.`);
          } catch (emailError) {
            console.error(`Error sending task assignment email to ${alumno.email}:`, emailError);
          }
        }
      }

      // Después de asignar la tarea a al menos un alumno, hacer visible la publicación asociada
      if (tareaMaestra.publicacionId && assignedTasks.length > 0) {
        const updatedPublicacion = await prisma.publicacion.update({
          where: { id: tareaMaestra.publicacionId },
          data: { visibleToStudents: true },
        });
        console.log('[DEBUG] Publicación actualizada a visible:', updatedPublicacion);
      }

      res.status(201).json({ message: `Tarea maestra asignada a ${assignedTasks.length} estudiantes.`, asignaciones: assignedTasks });

    } catch (error) {
      console.error('Error assigning master task to students:', error);
      res.status(500).json({ error: 'Failed to assign master task.', details: error.message });
    }
  });

  // Update a master task for a catedra (Docente only)
  router.put('/docentes/catedras/:catedraId/tareas/:tareaMaestraId', requireDocente, async (req, res) => {
    const { catedraId, tareaMaestraId } = req.params;
    const { titulo, descripcion, puntos_posibles, fecha_entrega, recursos, multimedia_path } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      // Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra not found or access denied.' });
      }

      // Verify the master task belongs to the catedra and exists
      const existingTareaMaestra = await prisma.tareaMaestra.findFirst({
        where: {
          id: parseInt(tareaMaestraId),
          catedraId: parseInt(catedraId),
        },
      });

      if (!existingTareaMaestra) {
        return res.status(404).json({ error: 'Tarea maestra no encontrada o no pertenece a esta cátedra.' });
      }

      const updatedTareaMaestra = await prisma.tareaMaestra.update({
        where: { id: parseInt(tareaMaestraId) },
        data: {
          titulo: titulo !== undefined ? titulo : existingTareaMaestra.titulo,
          descripcion: descripcion !== undefined ? descripcion : existingTareaMaestra.descripcion,
          puntos_posibles: puntos_posibles !== undefined ? parseInt(puntos_posibles) : existingTareaMaestra.puntos_posibles,
          fecha_entrega: fecha_entrega !== undefined ? new Date(fecha_entrega) : existingTareaMaestra.fecha_entrega,
          recursos: recursos !== undefined ? recursos : existingTareaMaestra.recursos,
          multimedia_path: multimedia_path !== undefined ? multimedia_path : existingTareaMaestra.multimedia_path,
        },
      });

      // Opcional: Actualizar la publicación si está asociada
      if (updatedTareaMaestra.publicacionId) {
        const publicacionTitle = updatedTareaMaestra.titulo && updatedTareaMaestra.titulo.trim() !== '' ? `Nueva Tarea: ${updatedTareaMaestra.titulo}` : 'Nueva Tarea Asignada';
        const formattedFechaEntrega = updatedTareaMaestra.fecha_entrega ? new Date(updatedTareaMaestra.fecha_entrega).toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric' }) : 'No definida';

        const publicacionContent = `
          Se ha actualizado la tarea: **${updatedTareaMaestra.titulo && updatedTareaMaestra.titulo.trim() !== '' ? updatedTareaMaestra.titulo : 'Sin título'}**.
          
          Descripción: ${updatedTareaMaestra.descripcion && updatedTareaMaestra.descripcion.trim() !== '' ? updatedTareaMaestra.descripcion : 'Sin descripción'}.
          Fecha de Entrega: ${formattedFechaEntrega}.
          

        `;

        await prisma.publicacion.update({
          where: { id: updatedTareaMaestra.publicacionId },
          data: {
            titulo: publicacionTitle,
            contenido: publicacionContent,
          },
        });
      }

      res.status(200).json(updatedTareaMaestra);
    } catch (error) {
      console.error('Error updating master task for docente:', error);
      res.status(500).json({ error: 'Failed to update master task.' });
    }
  });

  // Generate evaluation for a catedra
  router.post('/docentes/catedras/:catedraId/generate-evaluation', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const { topic, subject, numberOfQuestions, numberOfOptions } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      // Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        }
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra not found or access denied.' });
      }

      const generatedQuestions = await generateQuestionsWithAI(topic, numberOfQuestions, numberOfOptions);

      let evaluationTitle = topic;
      evaluationTitle = evaluationTitle.replace(/^Genera preguntas (de seleccion multiple |de selección múltiple )?sobre /i, '');
      evaluationTitle = evaluationTitle.replace(/^Crea una evaluación sobre /i, '');
      evaluationTitle = evaluationTitle.replace(/\.$/, '');

      const newEvaluation = await prisma.evaluacion.create({
        data: {
          titulo: `Evaluación de ${evaluationTitle} para ${catedra.nombre}`,
          catedraId: parseInt(catedraId),
          preguntas: {
            create: generatedQuestions.map(p => ({
              texto: p.texto,
              opciones: {
                create: p.opciones,
              },
            })),
          },
        },
        include: {
          preguntas: {
            include: {
              opciones: true,
            },
          },
        },
      });

      // Create a publicacion for the new evaluation in the catedra's board
      const publicacionTitle = `Nueva Evaluación: ${newEvaluation.titulo}`;
      const publicacionContent = `Se ha generado una nueva evaluación: **${newEvaluation.titulo}**.
        Puedes encontrarla en la pestaña de evaluaciones para su revisión y asignación.`

      console.log('DEBUG: Publicacion title (Evaluation):', publicacionTitle);
      console.log('DEBUG: Publicacion content (Evaluation):', publicacionContent);

      const newPublicacion = await prisma.publicacion.create({
        data: {
          titulo: publicacionTitle,
          contenido: publicacionContent,
          tipo: 'EVALUACION',
          catedraId: parseInt(catedraId),
          autorDocenteId: docenteId,
          visibleToStudents: false, // Evaluation is not visible to students until assigned
        },
      });

      console.log('DEBUG: New Publicacion created (Evaluation):', newPublicacion);

      // Fetch all students enrolled in the catedra to send notifications
      const enrolledStudents = await prisma.catedraAlumno.findMany({
        where: { catedraId: parseInt(catedraId), alumnoId: { not: null } },
        include: {
          alumno: {
            select: { email: true, nombre: true },
          },
        },
      });

      for (const enrollment of enrolledStudents) {
        if (enrollment.alumno && enrollment.alumno.email) {
          const mailOptions = {
            from: `"HMPY (Historia de la Música PY - Academia)" <${process.env.EMAIL_USER}>`,
            to: enrollment.alumno.email,
            subject: `¡Nueva Evaluación Disponible en ${catedra.nombre}!`,
            html: `
              <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #ffffff; background-color: #1a202c; padding: 20px;">
                <div style="max-width: 600px; margin: 0 auto; background-color: #2d3748; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
                  <h2 style="color: #9f7aea; text-align: center;">¡Hola ${enrollment.alumno.nombre}!</h2>
                  <p style="color: #e2e8f0;">Tu docente ha creado una nueva evaluación para la cátedra de <strong>${catedra.nombre}</strong>.</p>
                  <p style="color: #e2e8f0;"><strong>Título de la Evaluación:</strong> ${newEvaluation.titulo}</p>
                  <p style="color: #e2e8f0;">Puedes acceder a ella y realizarla desde tu panel de "Mis Evaluaciones" en la plataforma.</p>
                  <p style="color: #e2e8f0;">¡Mucho éxito!</p>
                  <p style="color: #cbd5e0; font-size: 0.9em; text-align: center; margin-top: 20px;">Atentamente, El Equipo de HMPY</p>
                </div>
              </div>
            `,
          };
          try {
            await transporter.sendMail(mailOptions);
            console.log(`Notification email sent to ${enrollment.alumno.email} for new evaluation.`);
          } catch (emailError) {
            console.error(`Error sending email to ${enrollment.alumno.email}:`, emailError);
          }
        }
      }

      res.status(201).json({
        message: '¡Evaluación generada y guardada exitosamente!',
        evaluation: newEvaluation,
      });
    } catch (error) {
      console.error('Error generating evaluation for docente:', error);
      // Log the full error object for better debugging
      console.error('Full error details:', JSON.stringify(error, null, 2));
      res.status(500).json({ error: 'Failed to generate evaluation.', details: error.message });
    }
  });

  // GET /docentes/catedras/:catedraId/evaluaciones-maestras - Obtener todas las evaluaciones maestras de una cátedra
  router.get("/docentes/catedras/:catedraId/evaluaciones-maestras", requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const evaluacionesMaestras = await prisma.evaluacion.findMany({
        where: {
          catedraId: parseInt(catedraId),
        },
        include: {
          _count: {
            select: { preguntas: true },
          },
        },
        orderBy: {
          created_at: 'desc',
        },
      });

      res.status(200).json(evaluacionesMaestras);
    } catch (error) {
      console.error(\'Error al obtener evaluaciones maestras:\', error);
      res.status(500).json({ error: \'Error al obtener las evaluaciones maestras.\', details: error.message });
    }
  });

  // POST /docentes/catedras/:catedraId/evaluaciones/:evaluationId/assign - Asignar una evaluación a alumnos
  router.post('/docentes/catedras/:catedraId/evaluaciones/:evaluationId/assign', requireDocente, async (req, res) => {
    const { catedraId, evaluationId } = req.params;
    const { alumnoIds, fecha_limite } = req.body; // Array de IDs de alumnos y fecha límite
    const docenteId = req.docente.docenteId;

    if (!Array.isArray(alumnoIds) || alumnoIds.length === 0) {
      return res.status(400).json({ error: 'Se requiere una lista de IDs de alumnos para asignar la evaluación.' });
    }

    try {
      // 1. Verificar la cátedra y la evaluación
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const evaluacionMaestra = await prisma.evaluacion.findUnique({
        where: { id: parseInt(evaluationId) },
        include: {
          publicacion: true, // Incluir la publicación asociada
        },
      });

      if (!evaluacionMaestra) {
        return res.status(404).json({ error: 'Evaluación maestra no encontrada.' });
      }

      if (evaluacionMaestra.catedraId !== parseInt(catedraId)) {
        return res.status(400).json({ error: 'La evaluación no pertenece a la cátedra especificada.' });
      }

      const assignedEvaluations = [];
      for (const alumnoId of alumnoIds) {
        const alumnoIdInt = parseInt(alumnoId);

        // Verificar que el alumno esté inscrito en la cátedra
        const enrollment = await prisma.catedraAlumno.findFirst({
          where: {
            catedraId: parseInt(catedraId),
            alumnoId: alumnoIdInt,
          },
          include: {
            alumno: true,
          },
        });

        if (!enrollment || !enrollment.alumno) {
          console.warn(`Alumno con ID ${alumnoId} no encontrado o no inscrito en la cátedra. Saltando asignación.`);
          continue;
        }

        // 2. Crear o actualizar EvaluacionAsignacion
        const asignacion = await prisma.evaluacionAsignacion.upsert({
          where: {
            alumnoId_evaluacionId: {
              alumnoId: alumnoIdInt,
              evaluacionId: parseInt(evaluationId),
            },
          },
          update: {
            fecha_entrega: fecha_limite ? new Date(fecha_limite) : null,
            estado: 'PENDIENTE', // Resetear a PENDIENTE si ya existía y se reasigna
          },
          create: {
            alumnoId: alumnoIdInt,
            evaluacionId: parseInt(evaluationId),
            fecha_entrega: fecha_limite ? new Date(fecha_limite) : null,
            estado: 'PENDIENTE',
          },
        });
        assignedEvaluations.push(asignacion);

        // 3. Enviar email de notificación
        if (enrollment.alumno.email) {
          const mailOptions = {
            from: `"HMPY (Historia de la Música PY - Academia)" <${process.env.EMAIL_USER}>`,
            to: enrollment.alumno.email,
            subject: `¡Nueva Evaluación Asignada en ${catedra.nombre}!`,
            html: `
              <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #ffffff; background-color: #1a202c; padding: 20px;">
                <div style="max-width: 600px; margin: 0 auto; background-color: #2d3748; padding: 30px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
                  <h2 style="color: #9f7aea; text-align: center;">¡Hola ${enrollment.alumno.nombre}!</h2>
                  <p style="color: #e2e8f0;">Tu docente ha asignado una nueva evaluación para la cátedra de <strong>${catedra.nombre}</strong>.</p>
                  <p style="color: #e2e8f0;"><strong>Título de la Evaluación:</strong> ${evaluacionMaestra.titulo}</p>
                  ${fecha_limite ? `<p style="color: #e2e8f0;"><strong>Fecha Límite:</strong> ${new Date(fecha_limite).toLocaleDateString()}</p>` : ''}
                  <p style="color: #e2e8f0;">Puedes acceder a ella y realizarla desde tu panel de "Mis Evaluaciones" en la plataforma.</p>
                  <p style="color: #e2e8f0;">¡Mucho éxito!</p>
                  <p style="color: #cbd5e0; font-size: 0.9em; text-align: center; margin-top: 20px;">Atentamente, El Equipo de HMPY</p>
                </div>
              </div>
            `,
          };
          try {
            await transporter.sendMail(mailOptions);
            console.log(`Evaluation assignment notification email sent to ${enrollment.alumno.email}.`);
          } catch (emailError) {
            console.error(`Error sending evaluation assignment email to ${enrollment.alumno.email}:`, emailError);
          }
        }
      }

      // 4. Actualizar la Publicacion asociada para que sea visible a los estudiantes
      if (evaluacionMaestra.publicacionId && assignedEvaluations.length > 0) {
        await prisma.publicacion.update({
          where: { id: evaluacionMaestra.publicacionId },
          data: { visibleToStudents: true },
        });
        console.log(`[DEBUG] Publicación de evaluación maestra ${evaluacionMaestra.publicacionId} actualizada a visible.`);
      }

      res.status(201).json({ message: `Evaluación asignada a ${assignedEvaluations.length} estudiantes.`, asignaciones: assignedEvaluations });

    } catch (error) {
      console.error('Error assigning evaluation to students:', error);
      res.status(500).json({ error: 'Error al asignar la evaluación.', details: error.message });
    }
  });

  // DELETE /docentes/catedras/:catedraId/evaluaciones/:evaluationId - Eliminar una evaluación
  router.delete('/docentes/catedras/:catedraId/evaluaciones/:evaluationId', requireDocente, async (req, res) => {
    const { catedraId, evaluationId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // 2. Verify the evaluation belongs to the catedra and exists
      const evaluationToDelete = await prisma.evaluacion.findFirst({
        where: {
          id: parseInt(evaluationId),
          catedraId: parseInt(catedraId),
        },
        include: {
          preguntas: {
            include: {
              opciones: true,
            },
          },
        },
      });

      if (!evaluationToDelete) {
        return res.status(404).json({ error: 'Evaluación no encontrada o no pertenece a esta cátedra.' });
      }

      // 3. Delete related CalificacionEvaluacion records first
      await prisma.calificacionEvaluacion.deleteMany({
        where: {
          evaluationId: parseInt(evaluationId),
        },
      });

      // 4. Delete related RespuestasAlumno records
      for (const pregunta of evaluationToDelete.preguntas) {
        await prisma.respuestaAlumno.deleteMany({
          where: {
            preguntaId: pregunta.id,
          },
        });
        // 5. Delete options for each question
        await prisma.opcion.deleteMany({
          where: {
            preguntaId: pregunta.id,
          },
        });
      }

      // 6. Delete questions
      await prisma.pregunta.deleteMany({
        where: {
          evaluacionId: parseInt(evaluationId),
        },
      });
      
      // 7. Finally, delete the evaluation
      await prisma.evaluacion.delete({
        where: { id: parseInt(evaluationId) },
      });

      res.status(200).json({ message: 'Evaluación eliminada exitosamente.' });
    } catch (error) {
      console.error('Error deleting evaluation for docente:', error);
      res.status(500).json({ error: 'Failed to delete evaluation.', details: error.message });
    }
  });

  // --- Rutas para la gestión de Planes de Clases ---

  // POST /docentes/catedras/:catedraId/planes - Crear un nuevo plan de clases
  router.post('/docentes/catedras/:catedraId/planes', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const { titulo, tipoOrganizacion } = req.body;
    const docenteId = req.docente.docenteId;

    if (!titulo || !tipoOrganizacion) {
      return res.status(400).json({ error: 'Título y tipo de organización son obligatorios.' });
    }

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const newPlanDeClases = await prisma.planDeClases.create({
        data: {
          titulo,
          tipoOrganizacion,
          docenteId: docenteId,
          catedraId: parseInt(catedraId),
        },
      });

      res.status(201).json(newPlanDeClases);
    } catch (error) {
      console.error('Error al crear plan de clases:', error);
      res.status(500).json({ error: 'Error al crear el plan de clases.', details: error.message });
    }
  });

  // GET /docentes/catedras/:catedraId/planes - Obtener todos los planes de clases de una cátedra
  router.get('/docentes/catedras/:catedraId/planes', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const planesDeClase = await prisma.planDeClases.findMany({
        where: {
          catedraId: parseInt(catedraId),
        },
        include: {
          unidades: true, // Incluir unidades para la visualización en el frontend
        },
        orderBy: {
          created_at: 'asc',
        },
      });

      res.status(200).json(planesDeClase);
    } catch (error) {
      console.error('Error al obtener planes de clases:', error);
      res.status(500).json({ error: 'Error al obtener los planes de clases.', details: error.message });
    }
  });

  // GET /docentes/planes/:planId - Obtener un plan de clases específico
  router.get('/docentes/planes/:planId', requireDocente, async (req, res) => {
    const { planId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const planDeClases = await prisma.planDeClases.findUnique({
        where: {
          id: parseInt(planId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
          unidades: true,
        },
      });

      if (!planDeClases) {
        return res.status(404).json({ error: 'Plan de clases no encontrado.' });
      }

      if (planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para ver este plan de clases.' });
      }

      res.status(200).json(planDeClases);
    } catch (error) {
      console.error('Error al obtener plan de clases:', error);
      res.status(500).json({ error: 'Error al obtener el plan de clases.', details: error.message });
    }
  });

  // PUT /docentes/planes/:planId - Actualizar un plan de clases
  router.put('/docentes/planes/:planId', requireDocente, async (req, res) => {
    const { planId } = req.params;
    const { titulo, tipoOrganizacion } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      const planDeClases = await prisma.planDeClases.findUnique({
        where: {
          id: parseInt(planId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!planDeClases) {
        return res.status(404).json({ error: 'Plan de clases no encontrado.' });
      }

      if (planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para actualizar este plan de clases.' });
      }

      const updatedPlanDeClases = await prisma.planDeClases.update({
        where: { id: parseInt(planId) },
        data: {
          titulo: titulo || undefined,
          tipoOrganizacion: tipoOrganizacion || undefined,
        },
      });

      res.status(200).json(updatedPlanDeClases);
    } catch (error) {
      console.error('Error al actualizar plan de clases:', error);
      res.status(500).json({ error: 'Error al actualizar el plan de clases.', details: error.message });
    }
  });

  // DELETE /docentes/planes/:planId - Eliminar un plan de clases
  router.delete('/docentes/planes/:planId', requireDocente, async (req, res) => {
    const { planId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const planDeClases = await prisma.planDeClases.findUnique({
        where: {
          id: parseInt(planId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
          unidades: true, // Para verificar si hay unidades asociadas
        },
      });

      if (!planDeClases) {
        return res.status(404).json({ error: 'Plan de clases no encontrado.' });
      }

      if (planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para eliminar este plan de clases.' });
      }

      // Eliminar todas las unidades asociadas primero
      await prisma.unidadPlan.deleteMany({
        where: { planDeClasesId: parseInt(planId) },
      });

      await prisma.planDeClases.delete({
        where: { id: parseInt(planId) },
      });

      res.status(204).send(); // No content
    } catch (error) {
      console.error('Error al eliminar plan de clases:', error);
      res.status(500).json({ error: 'Error al eliminar el plan de clases.', details: error.message });
    }
  });

  // --- Rutas para la gestión de Unidades del Plan de Clases ---

  // POST /docentes/planes/:planId/unidades - Crear una nueva unidad de plan
  router.post('/docentes/planes/:planId/unidades', requireDocente, async (req, res) => {
    const { planId } = req.params;
    const { periodo, contenido, capacidades, horasTeoricas, horasPracticas, estrategiasMetodologicas, mediosVerificacionEvaluacion, recursos } = req.body;
    const docenteId = req.docente.docenteId;

    if (!periodo || !contenido || capacidades === undefined || horasTeoricas === undefined || horasPracticas === undefined || estrategiasMetodologicas === undefined || mediosVerificacionEvaluacion === undefined) {
      return res.status(400).json({ error: 'Todos los campos de la unidad son obligatorios.' });
    }

    try {
      const planDeClases = await prisma.planDeClases.findUnique({
        where: {
          id: parseInt(planId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!planDeClases) {
        return res.status(404).json({ error: 'Plan de clases no encontrado.' });
      }

      if (planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para añadir unidades a este plan de clases.' });
      }

      const newUnidadPlan = await prisma.unidadPlan.create({
        data: {
          planDeClasesId: parseInt(planId),
          periodo,
          contenido,
          capacidades,
          horasTeoricas: parseInt(horasTeoricas),
          horasPracticas: parseInt(horasPracticas),
          estrategiasMetodologicas,
          mediosVerificacionEvaluacion,
          recursos: recursos || [],
        },
      });

      res.status(201).json(newUnidadPlan);
    } catch (error) {
      console.error('Error al crear unidad de plan:', error);
      res.status(500).json({ error: 'Error al crear la unidad del plan de clases.', details: error.message });
    }
  });

  // PUT /docentes/unidades/:unidadId - Actualizar una unidad de plan
  router.put('/docentes/unidades/:unidadId', requireDocente, async (req, res) => {
    const { unidadId } = req.params;
    const { periodo, contenido, capacidades, horasTeoricas, horasPracticas, estrategiasMetodologicas, mediosVerificacionEvaluacion, recursos } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      const unidadPlan = await prisma.unidadPlan.findUnique({
        where: {
          id: parseInt(unidadId),
        },
        include: {
          planDeClases: {
            include: {
              catedra: {
                select: { docenteId: true },
              },
            },
          },
        },
      });

      if (!unidadPlan) {
        return res.status(404).json({ error: 'Unidad de plan no encontrada.' });
      }

      if (unidadPlan.planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para actualizar esta unidad de plan.' });
      }

      const updatedUnidadPlan = await prisma.unidadPlan.update({
        where: { id: parseInt(unidadId) },
        data: {
          periodo: periodo || undefined,
          contenido: contenido || undefined,
          capacidades: capacidades || undefined,
          horasTeoricas: horasTeoricas !== undefined ? parseInt(horasTeoricas) : undefined,
          horasPracticas: horasPracticas !== undefined ? parseInt(horasPracticas) : undefined,
          estrategiasMetodologicas: estrategiasMetodologicas || undefined,
          mediosVerificacionEvaluacion: mediosVerificacionEvaluacion || undefined,
          recursos: recursos || undefined,
        },
      });

      res.status(200).json(updatedUnidadPlan);
    } catch (error) {
      console.error('Error al actualizar unidad de plan:', error);
      res.status(500).json({ error: 'Error al actualizar la unidad del plan de clases.', details: error.message });
    }
  });

  // DELETE /docentes/unidades/:unidadId - Eliminar una unidad de plan
  router.delete('/docentes/unidades/:unidadId', requireDocente, async (req, res) => {
    const { unidadId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const unidadPlan = await prisma.unidadPlan.findUnique({
        where: {
          id: parseInt(unidadId),
        },
        include: {
          planDeClases: {
            include: {
              catedra: {
                select: { docenteId: true },
              },
            },
          },
        },
      });

      if (!unidadPlan) {
        return res.status(404).json({ error: 'Unidad de plan no encontrada.' });
      }

      if (unidadPlan.planDeClases.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para eliminar esta unidad de plan.' });
      }

      await prisma.unidadPlan.delete({
        where: { id: parseInt(unidadId) },
      });

      res.status(204).send(); // No content
    } catch (error) {
      console.error('Error al eliminar unidad de plan:', error);
      res.status(500).json({ error: 'Error al eliminar la unidad del plan de clases.', details: error.message });
    }
  });

  // Admin: CRUD de Docentes (solo accesible por Admin)
  router.get('/docentes', requireDocente, async (req, res) => {
    try {
      const docentes = await prisma.docente.findMany({
        where: {
          otpEnabled: true, // Solo docentes que han completado el proceso de verificación OTP
          NOT: {
            // Excluir docentes con nombre y apellido por defecto, que son creados automáticamente
            // pero que no han completado el registro.
            nombre: { startsWith: prisma.docente.fields.email.name.split('@')[0] }, // Heuristic: filter by default name creation
            apellido: 'Docente',
          },
        },
        select: {
          id: true,
          nombre: true,
          apellido: true,
          email: true,
          telefono: true,
          direccion: true,
        },
        orderBy: { nombre: 'asc' },
      });
      res.json(docentes);
    } catch (error) {
      console.error('Error al obtener docentes:', error);
      res.status(500).json({ error: 'Error al obtener la lista de docentes', details: error.message });
    }
  });

  router.post('/docentes', requireDocente, async (req, res) => {
    const { nombre, apellido, email, telefono, direccion } = req.body;
    try {
      const newDocente = await prisma.docente.create({
        data: {
          nombre,
          apellido,
          email,
          telefono,
          direccion,
        },
      });
      res.status(201).json(newDocente);
    } catch (error) {
      console.error('Error al crear docente:', error);
      res.status(500).json({ error: 'Error al crear el docente', details: error.message });
    }
  });

  router.put('/docentes/:id', requireDocente, async (req, res) => {
    const { id } = req.params;
    const { nombre, apellido, email, telefono, direccion } = req.body;
    try {
      const updatedDocente = await prisma.docente.update({
        where: { id: parseInt(id) },
        data: {
          nombre,
          apellido,
          email,
          telefono,
          direccion,
        },
      });
      res.json(updatedDocente);
    } catch (error) {
      console.error('Error al actualizar docente:', error);
      res.status(500).json({ error: 'Error al actualizar el docente', details: error.message });
    }
  });

  router.delete('/docentes/:id', requireDocente, async (req, res) => {
    const { id } = req.params;
    try {
      await prisma.docente.delete({
        where: { id: parseInt(id) },
      });
      res.status(204).send();
    } catch (error) {
      console.error('Error al eliminar docente:', error);
      res.status(500).json({ error: 'Error al eliminar el docente', details: error.message });
    }
  });

  // Delete a master task from a catedra (Docente only)
  router.delete('/docentes/catedras/:catedraId/tareas/:tareaMaestraId', requireDocente, async (req, res) => {
    const { catedraId, tareaMaestraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra not found or access denied.' });
      }

      // Verify the master task belongs to the catedra and exists
      const tareaMaestraToDelete = await prisma.tareaMaestra.findFirst({
        where: {
          id: parseInt(tareaMaestraId),
          catedraId: parseInt(catedraId),
        },
        include: { asignaciones: true, publicacion: true },
      });

      if (!tareaMaestraToDelete) {
        return res.status(404).json({ error: 'Tarea maestra no encontrada o no pertenece a esta cátedra.' });
      }

      // 1. Eliminar los registros de Puntuacion asociados a las TareaAsignacion de esta TareaMaestra
      // Esto requiere iterar por cada asignación para encontrar las puntuaciones relacionadas
      for (const asignacion of tareaMaestraToDelete.asignaciones) {
        await prisma.puntuacion.deleteMany({
          where: {
            alumnoId: asignacion.alumnoId,
            catedraId: catedra.id,
            motivo: `Calificación de tarea: ${tareaMaestraToDelete.titulo}`,
            tipo: 'TAREA',
          },
        });
      }

      // 2. Eliminar todas las TareaAsignacion asociadas a esta TareaMaestra
      await prisma.tareaAsignacion.deleteMany({
        where: {
          tareaMaestraId: parseInt(tareaMaestraId),
        },
      });

      // 3. Eliminar la Publicacion asociada si existe
      if (tareaMaestraToDelete.publicacionId) {
        const publicacionId = tareaMaestraToDelete.publicacionId;

        // Eliminar interacciones asociadas a la publicación
        await prisma.publicacionInteraccion.deleteMany({
          where: { publicacionId: publicacionId },
        });

        // Eliminar comentarios asociados a la publicación
        await prisma.comentarioPublicacion.deleteMany({
          where: { publicacionId: publicacionId },
        });

        // Ahora eliminar la publicación
        await prisma.publicacion.deleteMany({
          where: { id: publicacionId },
        });
      }

      // 4. Finalmente, eliminar la TareaMaestra
      await prisma.tareaMaestra.delete({
        where: { id: parseInt(tareaMaestraId) },
      });

      res.status(200).json({ message: 'Tarea maestra y sus asignaciones eliminadas exitosamente.' });
    } catch (error) {
      console.error('Error deleting master task for docente:', error);
      res.status(500).json({ error: 'Failed to delete master task.', details: error.message });
    }
  });

  // Unenroll an alumno or composer from a catedra (Docente only)
  router.delete('/docentes/catedras/:catedraId/desinscribir', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const { alumnoId, composerId } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      if (!alumnoId && !composerId) {
        return res.status(400).json({ error: 'Se requiere alumnoId o composerId para desinscribir.' });
      }

      // Verify the catedra belongs to the docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const whereClause = {
        catedraId: parseInt(catedraId, 10),
        ...(alumnoId && { alumnoId: parseInt(alumnoId, 10) }),
        ...(composerId && { composerId: parseInt(composerId, 10) }),
      };

      // Eliminar las TareaAsignacion del alumno en esta cátedra
      if (alumnoId) {
        await prisma.tareaAsignacion.deleteMany({
          where: {
            alumnoId: parseInt(alumnoId),
            tareaMaestra: {
              catedraId: parseInt(catedraId),
            },
          },
        });
      }

      const deleteResult = await prisma.catedraAlumno.deleteMany({
        where: whereClause,
      });

      if (deleteResult.count === 0) {
        return res.status(404).json({ error: 'Inscripción no encontrada en esta cátedra.' });
      }

      res.json({ message: 'Desinscripción exitosa.' });
    } catch (error) {
      console.error('Error al desinscribir alumno/compositor para docente:', error);
      res.status(500).json({ error: 'Error al desinscribir alumno/compositor.', details: error.message });
    }
  });

  // Get all tasks and submissions for a specific student in a catedra
  router.get('/docentes/catedras/:catedraId/alumnos/:alumnoId/entregas', requireDocente, async (req, res) => {
    const { catedraId, alumnoId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verify the docente owns the catedra
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
        include: {
          alumnos: {
            where: { alumnoId: parseInt(alumnoId) },
            include: { alumno: true }
          }
        }
      });

      if (!catedra || catedra.alumnos.length === 0) {
        return res.status(404).json({ error: 'Cátedra no encontrada, acceso denegado o el alumno no está inscrito.' });
      }

      const alumno = catedra.alumnos[0].alumno;

      // 2. Get all task assignments for the specific student in this catedra
      const asignacionesDelAlumno = await prisma.tareaAsignacion.findMany({
        where: {
          alumnoId: parseInt(alumnoId),
          tareaMaestra: {
            catedraId: parseInt(catedraId),
          },
        },
        include: {
          tareaMaestra: true,
        },
        orderBy: {
          tareaMaestra: {
            fecha_entrega: 'asc',
          },
        },
      });

      // 3. Format the results
      const resultado = asignacionesDelAlumno.map(asignacion => ({
        id: asignacion.id, // ID de la asignación
        titulo: asignacion.tareaMaestra.titulo,
        descripcion: asignacion.tareaMaestra.descripcion,
        fecha_entrega: asignacion.tareaMaestra.fecha_entrega,
        puntos_posibles: asignacion.tareaMaestra.puntos_posibles,
        recursos: asignacion.tareaMaestra.recursos,
        multimedia_path: asignacion.tareaMaestra.multimedia_path,
        estado: asignacion.estado,
        submission_path: asignacion.submission_path,
        submission_date: asignacion.submission_date,
        puntos_obtenidos: asignacion.puntos_obtenidos,
        catedraId: asignacion.tareaMaestra.catedraId,
        alumnoId: asignacion.alumnoId,
        tareaMaestraId: asignacion.tareaMaestraId,
      }));

      res.json({
        alumno: alumno,
        tareasConEntregas: resultado,
      });

    } catch (error) {
      console.error('Error fetching student submissions for docente:', error);
      res.status(500).json({ error: 'Error al obtener las entregas del alumno.' });
    }
  });

  // Grade a student's submission by updating the TareaAsignacion record
  router.post('/docentes/tareasAsignaciones/:tareaAsignacionId/calificar', requireDocente, async (req, res) => {
    const { tareaAsignacionId } = req.params;
    const { puntos_obtenidos, comentario_docente } = req.body;
    const docenteId = req.docente.docenteId;

    if (puntos_obtenidos === undefined) {
      return res.status(400).json({ error: 'Los puntos obtenidos son requeridos.' });
    }

    const puntos = parseInt(puntos_obtenidos);

    try {
      // 1. Find the task assignment and include related data for validation
      const asignacion = await prisma.tareaAsignacion.findUnique({
        where: { id: parseInt(tareaAsignacionId) },
        include: {
          tareaMaestra: {
            include: {
              catedra: true,
            },
          },
        },
      });

      if (!asignacion) {
        return res.status(404).json({ error: 'Asignación de tarea no encontrada.' });
      }

      // 2. Verify the docente owns the catedra this task belongs to
      if (asignacion.tareaMaestra.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para calificar esta asignación de tarea.' });
      }
      
      if (puntos > asignacion.tareaMaestra.puntos_posibles) {
        return res.status(400).json({ error: `La calificación no puede exceder los ${asignacion.tareaMaestra.puntos_posibles} puntos posibles.` });
      }

      // 3. Update the task assignment with the grade and set status to CALIFICADA
      const asignacionCalificada = await prisma.tareaAsignacion.update({
        where: { id: parseInt(tareaAsignacionId) },
        data: {
          puntos_obtenidos: puntos,
          estado: 'CALIFICADA',
          // Add comentario_docente here if you add it to the prisma schema
        },
      });

      // 4. Create or update the Puntuacion record
      const motivo = `Calificación de tarea: ${asignacion.tareaMaestra.titulo}`;
      
      const puntuacionExistente = await prisma.puntuacion.findFirst({
          where: {
              alumnoId: asignacion.alumnoId,
              catedraId: asignacion.tareaMaestra.catedraId,
              motivo: motivo,
              tipo: 'TAREA',
          }
      });

      if (puntuacionExistente) {
          await prisma.puntuacion.update({
              where: { id: puntuacionExistente.id },
              data: { puntos: puntos },
          });
      } else {
          await prisma.puntuacion.create({
              data: {
                  puntos: puntos,
                  motivo: motivo,
                  tipo: 'TAREA',
                  alumno: { connect: { id: asignacion.alumnoId } },
                  catedra: { connect: { id: asignacion.tareaMaestra.catedraId } },
              },
          });
      }

      res.json(asignacionCalificada);

    } catch (error) {
      console.error('Error grading submission:', error);
      res.status(500).json({ error: 'Error al calificar la entrega.' });
    }
  });

  // Get all evaluations for a specific student in a catedra (Docente only)
  router.get('/docentes/catedras/:catedraId/alumnos/:alumnoId/evaluaciones', requireDocente, async (req, res) => {
    const { catedraId, alumnoId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verify the docente owns the catedra
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
        include: {
          alumnos: {
            where: { alumnoId: parseInt(alumnoId) },
            include: { alumno: true }
          }
        }
      });

      if (!catedra || catedra.alumnos.length === 0) {
        return res.status(404).json({ error: 'Cátedra no encontrada, acceso denegado o el alumno no está inscrito.' });
      }

      // 2. Get all evaluations for this catedra
      const evaluations = await prisma.evaluacion.findMany({
        where: {
          catedraId: parseInt(catedraId),
        },
        include: {
          calificaciones: {
            where: { alumnoId: parseInt(alumnoId) },
            select: { puntos: true, created_at: true },
          },
        },
        orderBy: { created_at: 'desc' },
      });

      // 3. Map evaluations to include status for the specific student
      const evaluationsWithStatus = evaluations.map(evaluation => ({
        id: evaluation.id,
        titulo: evaluation.titulo,
        created_at: evaluation.created_at,
        catedraId: evaluation.catedraId,
        puntos_obtenidos: evaluation.calificaciones.length > 0 ? evaluation.calificaciones[0].puntos : null,
        estado: evaluation.calificaciones.length > 0 ? 'CALIFICADA' : 'PENDIENTE',
      }));

      res.json(evaluationsWithStatus);

    } catch (error) {
      console.error('Error fetching student evaluations for docente:', error);
      res.status(500).json({ error: 'Error al obtener las evaluaciones del alumno.' });
    }
  });

  // Get evaluation results for a specific student in a catedra (Docente only)
  router.get('/docentes/catedras/:catedraId/alumnos/:alumnoId/evaluaciones/:evaluationId/results', requireDocente, async (req, res) => {
    const { catedraId, alumnoId, evaluationId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verify the docente owns the catedra and the student is enrolled
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
        include: {
          alumnos: {
            where: { alumnoId: parseInt(alumnoId) },
            include: { alumno: true },
          },
        },
      });

      if (!catedra || catedra.alumnos.length === 0) {
        return res.status(404).json({ error: 'Cátedra no encontrada, acceso denegado o el alumno no está inscrito.' });
      }

      const alumno = catedra.alumnos[0].alumno;

      // 2. Fetch the evaluation with questions and options
      const evaluation = await prisma.evaluacion.findUnique({
        where: { id: parseInt(evaluationId) },
        include: {
          preguntas: {
            include: {
              opciones: true,
            },
          },
          calificaciones: {
            where: { alumnoId: parseInt(alumnoId) },
            select: { id: true, puntos: true, respuestas: true, created_at: true },
          },
        },
      });

      if (!evaluation) {
        return res.status(404).json({ error: 'Evaluación no encontrada.' });
      }

      if (evaluation.catedraId !== parseInt(catedraId)) {
        return res.status(400).json({ error: 'La evaluación no pertenece a esta cátedra.' });
      }

      const studentScore = evaluation.calificaciones.length > 0 ? evaluation.calificaciones[0].puntos : 0;
      const studentAnswers = evaluation.calificaciones.length > 0 ? JSON.parse(evaluation.calificaciones[0].respuestas) : {};

      let totalPossiblePoints = 0;
      const formattedQuestions = evaluation.preguntas.map(question => {
        const correctAnswer = question.opciones.find(opt => opt.es_correcta);
        totalPossiblePoints += 1; // Each question is 1 point
        return {
          id: question.id,
          text: question.texto,
          options: question.opciones.map(option => ({
            id: option.id,
            text: option.texto,
          })),
          correctAnswerId: correctAnswer ? correctAnswer.id : null,
          alumnoAnswerId: studentAnswers[question.id] || null,
        };
      });

      res.json({
        evaluationTitle: evaluation.titulo,
        alumnoNombre: alumno.nombre,
        alumnoApellido: alumno.apellido,
        score: studentScore,
        totalPoints: totalPossiblePoints,
        questions: formattedQuestions,
      });

    } catch (error) {
      console.error('Error fetching evaluation results for docente:', error);
      res.status(500).json({ error: 'Error al obtener los resultados de la evaluación.' });
    }
  });

  // Get a specific evaluation by ID for the logged-in docente
  router.get('/docentes/evaluaciones/:evaluationId', requireDocente, async (req, res) => {
    const { evaluationId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const evaluation = await prisma.evaluacion.findUnique({
        where: { id: parseInt(evaluationId) },
        include: {
          catedra: {
            select: { docenteId: true }
          },
          preguntas: {
            include: {
              opciones: true,
            },
          },
        },
      });

      if (!evaluation) {
        return res.status(404).json({ error: 'Evaluación no encontrada.' });
      }

      // Verify the catedra of the evaluation belongs to the docente
      if (!evaluation.catedra || evaluation.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para ver esta evaluación.' });
      }

      res.json(evaluation);

    } catch (error) {
      console.error('Error fetching evaluation for docente:', error);
      res.status(500).json({ error: 'Error al obtener la evaluación.' });
    }
  });

  // --- Rutas para la gestión de Días de Clase ---

  // POST /docentes/catedras/:catedraId/diasclase - Crear un nuevo día de clase
  router.post('/docentes/catedras/:catedraId/diasclase', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const { fecha, dia_semana } = req.body;
    const docenteId = req.docente.docenteId;

    if (!fecha || !dia_semana) {
      return res.status(400).json({ error: 'Fecha y día de la semana son obligatorios.' });
    }

    try {
      // La cadena 'YYYY-MM-DD' se interpreta como medianoche UTC, que es lo correcto.
      const fechaUTC = new Date(fecha);

      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const newDiaClase = await prisma.diaClase.create({
        data: {
          fecha: fechaUTC,
          dia_semana,
          catedraId: parseInt(catedraId),
        },
      });

      res.status(201).json(newDiaClase);
    } catch (error) {
      console.error('Error al crear día de clase:', error);
      res.status(500).json({ error: 'Error al crear el día de clase.', details: error.message });
    }
  });

  // GET /docentes/catedras/:catedraId/diasclase - Obtener todos los días de clase de una cátedra
  router.get('/docentes/catedras/:catedraId/diasclase', requireDocente, async (req, res) => {
    const { catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      const diasClase = await prisma.diaClase.findMany({
        where: {
          catedraId: parseInt(catedraId),
        },
        orderBy: {
          fecha: 'asc',
        },
      });

      res.status(200).json(diasClase);
    } catch (error) {
      console.error('Error al obtener días de clase:', error);
      res.status(500).json({ error: 'Error al obtener los días de clase.', details: error.message });
    }
  });

  // GET /docentes/diasclase/:diaClaseId - Obtener un día de clase específico
  router.get('/docentes/diasclase/:diaClaseId', requireDocente, async (req, res) => {
    const { diaClaseId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const diaClase = await prisma.diaClase.findUnique({
        where: {
          id: parseInt(diaClaseId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!diaClase) {
        return res.status(404).json({ error: 'Día de clase no encontrado.' });
      }

      if (diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para ver este día de clase.' });
      }

      res.status(200).json(diaClase);
    } catch (error) {
      console.error('Error al obtener día de clase:', error);
      res.status(500).json({ error: 'Error al obtener el día de clase.', details: error.message });
    }
  });

  // PUT /docentes/diasclase/:diaClaseId - Actualizar un día de clase
  router.put('/docentes/diasclase/:diaClaseId', requireDocente, async (req, res) => {
    const { diaClaseId } = req.params;
    const { fecha, dia_semana } = req.body;
    const docenteId = req.docente.docenteId;

    try {
      const diaClase = await prisma.diaClase.findUnique({
        where: {
          id: parseInt(diaClaseId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!diaClase) {
        return res.status(404).json({ error: 'Día de clase no encontrado.' });
      }

      if (diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para actualizar este día de clase.' });
      }

      let fechaUTC;
      if (fecha) {
        // La cadena 'YYYY-MM-DD' se interpreta como medianoche UTC.
        fechaUTC = new Date(fecha);
      }

      const updatedDiaClase = await prisma.diaClase.update({
        where: { id: parseInt(diaClaseId) },
        data: {
          fecha: fechaUTC, // Usar la fecha UTC o undefined si no se proveyó
          dia_semana: dia_semana || undefined,
        },
      });

      res.status(200).json(updatedDiaClase);
    } catch (error) {
      console.error('Error al actualizar día de clase:', error);
      res.status(500).json({ error: 'Error al actualizar el día de clase.', details: error.message });
    }
  });

  // DELETE /docentes/diasclase/:diaClaseId - Eliminar un día de clase
  router.delete('/docentes/diasclase/:diaClaseId', requireDocente, async (req, res) => {
    const { diaClaseId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const diaClase = await prisma.diaClase.findUnique({
        where: {
          id: parseInt(diaClaseId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!diaClase) {
        return res.status(404).json({ error: 'Día de clase no encontrado.' });
      }

      if (diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para eliminar este día de clase.' });
      }

      // Eliminar registros de asistencia asociados primero
      await prisma.asistencia.deleteMany({
        where: { diaClaseId: parseInt(diaClaseId) },
      });

      await prisma.diaClase.delete({
        where: { id: parseInt(diaClaseId) },
      });

      res.status(204).send(); // No content
    } catch (error) {
      console.error('Error al eliminar día de clase:', error);
      res.status(500).json({ error: 'Error al eliminar el día de clase.', details: error.message });
    }
  });

  // --- Rutas para la gestión de Asistencia ---

  // POST /docentes/diasclase/:diaClaseId/asistencias - Registrar la asistencia de alumnos para un día de clase
  router.post('/docentes/diasclase/:diaClaseId/asistencias', requireDocente, async (req, res) => {
    const { diaClaseId } = req.params;
    const { asistencias } = req.body; // [{ alumnoId: 1, presente: true }, { alumnoId: 2, presente: false }]
    const docenteId = req.docente.docenteId;

    if (!Array.isArray(asistencias) || asistencias.length === 0) {
      return res.status(400).json({ error: 'Se requiere una lista de asistencias.' });
    }

    try {
      const diaClase = await prisma.diaClase.findUnique({
        where: {
          id: parseInt(diaClaseId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!diaClase) {
        return res.status(404).json({ error: 'Día de clase no encontrado.' });
      }

      if (diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para registrar asistencia en este día de clase.' });
      }

      const results = [];
      for (const asistenciaData of asistencias) {
        const { alumnoId, presente } = asistenciaData;
        if (alumnoId === undefined || presente === undefined) {
          console.warn(`Registro de asistencia inválido: ${JSON.stringify(asistenciaData)}`);
          continue;
        }

        try {
          const asistencia = await prisma.asistencia.upsert({
            where: {
              alumnoId_diaClaseId: {
                alumnoId: parseInt(alumnoId),
                diaClaseId: parseInt(diaClaseId),
              },
            },
            update: {
              presente,
            },
            create: {
              alumnoId: parseInt(alumnoId),
              diaClaseId: parseInt(diaClaseId),
              presente,
            },
          });
          results.push(asistencia);
        } catch (upsertError) {
          console.error(`Error al registrar/actualizar asistencia para alumno ${alumnoId} en día de clase ${diaClaseId}:`, upsertError);
          // Opcional: Podrías devolver un error específico para cada asistencia fallida o continuar
        }
      }
      res.status(200).json({ message: 'Asistencias procesadas exitosamente.', results });
    } catch (error) {
      console.error('Error al procesar asistencias:', error);
      res.status(500).json({ error: 'Error al procesar las asistencias.', details: error.message });
    }
  });

  // GET /docentes/diasclase/:diaClaseId/asistencias - Obtener la lista de asistencia de un día de clase
  router.get('/docentes/diasclase/:diaClaseId/asistencias', requireDocente, async (req, res) => {
    const { diaClaseId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const diaClase = await prisma.diaClase.findUnique({
        where: {
          id: parseInt(diaClaseId),
        },
        include: {
          catedra: {
            select: { docenteId: true },
          },
        },
      });

      if (!diaClase) {
        return res.status(404).json({ error: 'Día de clase no encontrado.' });
      }

      if (diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para ver la asistencia de este día de clase.' });
      }

      const asistencias = await prisma.asistencia.findMany({
        where: {
          diaClaseId: parseInt(diaClaseId),
        },
        include: {
          alumno: {
            select: { id: true, nombre: true, apellido: true, email: true },
          },
        },
        orderBy: {
          alumno: {
            apellido: 'asc',
          },
        },
      });

      res.status(200).json(asistencias);
    } catch (error) {
      console.error('Error al obtener la lista de asistencia:', error);
      res.status(500).json({ error: 'Error al obtener la lista de asistencia.', details: error.message });
    }
  });

  // PUT /docentes/asistencias/:asistenciaId - Actualizar un registro de asistencia específico
  router.put('/docentes/asistencias/:asistenciaId', requireDocente, async (req, res) => {
    const { asistenciaId } = req.params;
    const { presente } = req.body;
    const docenteId = req.docente.docenteId;

    if (presente === undefined) {
      return res.status(400).json({ error: 'El estado de presencia es obligatorio.' });
    }

    try {
      const asistencia = await prisma.asistencia.findUnique({
        where: {
          id: parseInt(asistenciaId),
        },
        include: {
          diaClase: {
            include: {
              catedra: {
                select: { docenteId: true },
              },
            },
          },
        },
      });

      if (!asistencia) {
        return res.status(404).json({ error: 'Registro de asistencia no encontrado.' });
      }

      if (asistencia.diaClase.catedra.docenteId !== docenteId) {
        return res.status(403).json({ error: 'No tiene permiso para actualizar este registro de asistencia.' });
      }

      const updatedAsistencia = await prisma.asistencia.update({
        where: { id: parseInt(asistenciaId) },
        data: {
          presente,
        },
      });

      res.status(200).json(updatedAsistencia);
    } catch (error) {
      console.error('Error al actualizar asistencia:', error);
      res.status(500).json({ error: 'Error al actualizar el registro de asistencia.', details: error.message });
    }
  });

  // GET /api/alumno/asistencias/catedra/:catedraId - Obtener la asistencia de un alumno en una cátedra específica
  // NOTA: Este endpoint está en docenteRoutes temporalmente. Se moverá a alumnoRoutes.js si se crea.
  router.get('/docentes/alumnos/:alumnoId/catedras/:catedraId/asistencias', requireDocente, async (req, res) => {
    const { alumnoId, catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // Verificar que la cátedra pertenezca al docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // Verificar que el alumno esté inscrito en la cátedra
      const catedraAlumno = await prisma.catedraAlumno.findUnique({
        where: {
          catedraId_alumnoId: {
            catedraId: parseInt(catedraId),
            alumnoId: parseInt(alumnoId),
          },
        },
      });

      if (!catedraAlumno) {
        return res.status(404).json({ error: 'El alumno no está inscrito en esta cátedra.' });
      }

      const asistencias = await prisma.asistencia.findMany({
        where: {
          alumnoId: parseInt(alumnoId),
          diaClase: {
            catedraId: parseInt(catedraId),
          },
        },
        include: {
          diaClase: {
            select: { id: true, fecha: true, dia_semana: true },
          },
        },
        orderBy: {
          diaClase: {
            fecha: 'asc',
          },
        },
      });

      res.status(200).json(asistencias);
    } catch (error) {
      console.error('Error al obtener asistencias del alumno:', error);
      res.status(500).json({ error: 'Error al obtener las asistencias del alumno.', details: error.message });
    }
  });

  // GET /docentes/alumnos/:alumnoId/pagos - Obtener el estado de pago consolidado de un alumno para un docente
  router.get('/docentes/alumnos/:alumnoId/pagos', requireDocente, async (req, res) => {
    const { alumnoId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      const catedrasAlumno = await prisma.catedraAlumno.findMany({
        where: {
          alumnoId: parseInt(alumnoId),
          catedra: {
            docenteId: docenteId,
          },
        },
        include: {
          alumno: {
            select: { id: true, nombre: true, apellido: true, email: true },
          },
          catedra: {
            select: { id: true, nombre: true, modalidad_pago: true, costos: true },
          },
          pagos: {
            orderBy: { fecha_pago: 'desc' },
          },
        },
      });

      if (catedrasAlumno.length === 0) {
        return res.status(404).json({ error: 'El alumno no está inscrito en ninguna cátedra de este docente o no tiene información de pago.' });
      }

      const pagosConsolidados = catedrasAlumno.map(ca => {
        const { alumno, catedra, dia_cobro, fecha_inscripcion, pagos } = ca;
        const costosCatedra = catedra.costos;

        const estadoPagoCatedra = {
          catedraId: catedra.id,
          catedraNombre: catedra.nombre,
          modalidadPago: catedra.modalidad_pago,
          fechaInscripcion: fecha_inscripcion,
          diaCobroMensual: dia_cobro,
          estadoActual: 'DESCONOCIDO',
          deudaMatricula: 0,
          deudaCuotas: [],
          totalDeuda: 0,
        };

        if (costosCatedra && costosCatedra.es_gratuita) {
          estadoPagoCatedra.estadoActual = 'GRATUITO';
        } else {
          // Lógica para matrícula
          if (costosCatedra && costosCatedra.monto_matricula) {
            const pagoMatricula = pagos.find(p => p.tipo_pago === 'MATRICULA');
            if (!pagoMatricula) {
              estadoPagoCatedra.estadoActual = 'MATRÍCULA PENDIENTE';
              estadoPagoCatedra.deudaMatricula = costosCatedra.monto_matricula;
              estadoPagoCatedra.totalDeuda += costosCatedra.monto_matricula;
            } else if (pagoMatricula.monto_pagado < costosCatedra.monto_matricula) {
              estadoPagoCatedra.estadoActual = 'MATRÍCULA PARCIALMENTE PAGADA';
              estadoPagoCatedra.deudaMatricula = costosCatedra.monto_matricula - pagoMatricula.monto_pagado;
              estadoPagoCatedra.totalDeuda += estadoPagoCatedra.deudaMatricula;
            }
          }

          // Lógica para cuotas
          if (costosCatedra && costosCatedra.monto_cuota && dia_cobro) {
            const hoy = new Date();
            let mesActual = hoy.getMonth();
            let anoActual = hoy.getFullYear();

            const fechaInicioCuota = new Date(fecha_inscripcion);
            fechaInicioCuota.setDate(dia_cobro);

            let currentMonth = fechaInicioCuota.getMonth();
            let currentYear = fechaInicioCuota.getFullYear();

            while (currentYear < anoActual || (currentYear === anoActual && currentMonth <= mesActual)) {
              const tempDate = new Date(currentYear, currentMonth, dia_cobro);
              if (tempDate.getMonth() !== currentMonth) {
                tempDate.setDate(0);
                tempDate.setDate(dia_cobro);
              }

              const periodo = `${tempDate.toLocaleString('es-ES', { month: 'long' })} ${currentYear}`;
              const pagoCuota = pagos.find(p => p.tipo_pago === 'CUOTA' && p.periodo_cubierto === periodo);

              if (!pagoCuota) {
                if (hoy.getDate() > dia_cobro || (hoy.getMonth() > currentMonth && hoy.getFullYear() === currentYear) || hoy.getFullYear() > currentYear) {
                  estadoPagoCatedra.deudaCuotas.push({
                    periodo: periodo,
                    monto: costosCatedra.monto_cuota,
                    estado: 'PENDIENTE',
                  });
                  estadoPagoCatedra.totalDeuda += costosCatedra.monto_cuota;
                }
              } else if (pagoCuota.monto_pagado < costosCatedra.monto_cuota) {
                const montoPendienteCuota = costosCatedra.monto_cuota - pagoCuota.monto_pagado;
                estadoPagoCatedra.deudaCuotas.push({
                  periodo: periodo,
                  monto: montoPendienteCuota,
                  estado: 'PAGO PARCIAL',
                });
                estadoPagoCatedra.totalDeuda += montoPendienteCuota;
              }

              currentMonth++;
              if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
              }
              if (currentYear > anoActual || (currentYear === anoActual && currentMonth > mesActual)) break;
            }

            if (estadoPagoCatedra.totalDeuda === 0) {
              estadoPagoCatedra.estadoActual = 'AL DÍA';
            } else if (estadoPagoCatedra.totalDeuda > 0) {
              estadoPagoCatedra.estadoActual = 'EN MORA';
            }
          }
        }
        return estadoPagoCatedra;
      });

      res.status(200).json({
        alumno: {
          id: catedrasAlumno[0].alumno.id,
          nombre: catedrasAlumno[0].alumno.nombre,
          apellido: catedrasAlumno[0].alumno.apellido,
          email: catedrasAlumno[0].alumno.email,
        },
        pagosPorCatedra: pagosConsolidados,
      });

    } catch (error) {
      console.error('Error al obtener el estado de pagos del alumno para docente:', error);
      res.status(500).json({ error: 'Error al obtener el estado de pagos del alumno.', details: error.message });
    }
  });

  // --- Rutas para la gestión de Pagos (Docente) ---

  // POST /docentes/alumnos/:alumnoId/catedras/:catedraId/pagos - Registrar un pago
  router.post('/docentes/alumnos/:alumnoId/catedras/:catedraId/pagos', requireDocente, async (req, res) => {
    const { alumnoId, catedraId } = req.params;
    const { monto_pagado, tipo_pago, periodo_cubierto } = req.body;
    const docenteId = req.docente.docenteId;

    if (monto_pagado === undefined || tipo_pago === undefined) {
      return res.status(400).json({ error: 'Monto pagado y tipo de pago son obligatorios.' });
    }
    if (!['MATRICULA', 'CUOTA', 'OTRO'].includes(tipo_pago)) {
      return res.status(400).json({ error: 'Tipo de pago inválido. Debe ser MATRICULA, CUOTA o OTRO.' });
    }
    if (tipo_pago === 'CUOTA' && !periodo_cubierto) {
      return res.status(400).json({ error: 'El periodo cubierto es obligatorio para pagos de cuota.' });
    }

    try {
      // 1. Verificar que la cátedra pertenezca al docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // 2. Verificar que el alumno esté inscrito en la cátedra
      const catedraAlumno = await prisma.catedraAlumno.findUnique({
        where: {
          catedraId_alumnoId: {
            catedraId: parseInt(catedraId),
            alumnoId: parseInt(alumnoId),
          },
        },
      });

      if (!catedraAlumno) {
        return res.status(404).json({ error: 'El alumno no está inscrito en esta cátedra.' });
      }

      const newPago = await prisma.pago.create({
        data: {
          catedraAlumnoId: catedraAlumno.id,
          monto_pagado: parseFloat(monto_pagado),
          tipo_pago: tipo_pago,
          periodo_cubierto: periodo_cubierto || null,
          confirmadoPorId: docenteId, // El docente que registra el pago
        },
      });

      res.status(201).json(newPago);
    } catch (error) {
      console.error('Error al registrar pago:', error);
      res.status(500).json({ error: 'Error al registrar el pago.', details: error.message });
    }
  });

  // GET /docentes/alumnos/:alumnoId/catedras/:catedraId/pagos - Obtener el historial de pagos de un alumno en una cátedra
  router.get('/docentes/alumnos/:alumnoId/catedras/:catedraId/pagos', requireDocente, async (req, res) => {
    const { alumnoId, catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verificar que la cátedra pertenezca al docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // 2. Verificar que el alumno esté inscrito en la cátedra
      const catedraAlumno = await prisma.catedraAlumno.findUnique({
        where: {
          catedraId_alumnoId: {
            catedraId: parseInt(catedraId),
            alumnoId: parseInt(alumnoId),
          },
        },
        select: { id: true }, // Solo necesitamos el ID de CatedraAlumno
      });

      if (!catedraAlumno) {
        return res.status(404).json({ error: 'El alumno no está inscrito en esta cátedra.' });
      }

      const pagos = await prisma.pago.findMany({
        where: {
          catedraAlumnoId: catedraAlumno.id,
        },
        include: {
          confirmado_por: {
            select: { nombre: true, apellido: true },
          },
        },
        orderBy: {
          fecha_pago: 'desc',
        },
      });

      res.status(200).json(pagos);
    } catch (error) {
      console.error('Error al obtener historial de pagos del alumno:', error);
      res.status(500).json({ error: 'Error al obtener el historial de pagos.', details: error.message });
    }
  });

  // --- Rutas para la gestión de Pagos (Docente) ---

  // POST /docentes/alumnos/:alumnoId/catedras/:catedraId/pagos - Registrar un pago
  router.post('/docentes/alumnos/:alumnoId/catedras/:catedraId/pagos', requireDocente, async (req, res) => {
    const { alumnoId, catedraId } = req.params;
    const { monto_pagado, tipo_pago, periodo_cubierto } = req.body;
    const docenteId = req.docente.docenteId;

    if (monto_pagado === undefined || tipo_pago === undefined) {
      return res.status(400).json({ error: 'Monto pagado y tipo de pago son obligatorios.' });
    }
    if (!['MATRICULA', 'CUOTA', 'OTRO'].includes(tipo_pago)) {
      return res.status(400).json({ error: 'Tipo de pago inválido. Debe ser MATRICULA, CUOTA o OTRO.' });
    }
    if (tipo_pago === 'CUOTA' && !periodo_cubierto) {
      return res.status(400).json({ error: 'El periodo cubierto es obligatorio para pagos de cuota.' });
    }

    try {
      // 1. Verificar que la cátedra pertenezca al docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // 2. Verificar que el alumno esté inscrito en la cátedra
      const catedraAlumno = await prisma.catedraAlumno.findUnique({
        where: {
          catedraId_alumnoId: {
            catedraId: parseInt(catedraId),
            alumnoId: parseInt(alumnoId),
          },
        },
      });

      if (!catedraAlumno) {
        return res.status(404).json({ error: 'El alumno no está inscrito en esta cátedra.' });
      }

      const newPago = await prisma.pago.create({
        data: {
          catedraAlumnoId: catedraAlumno.id,
          monto_pagado: parseFloat(monto_pagado),
          tipo_pago: tipo_pago,
          periodo_cubierto: periodo_cubierto || null,
          confirmadoPorId: docenteId, // El docente que registra el pago
        },
      });

      res.status(201).json(newPago);
    } catch (error) {
      console.error('Error al registrar pago:', error);
      res.status(500).json({ error: 'Error al registrar el pago.', details: error.message });
    }
  });

  // GET /docentes/alumnos/:alumnoId/catedras/:catedraId/pagos - Obtener el historial de pagos de un alumno en una cátedra
  router.get('/docentes/alumnos/:alumnoId/catedras/:catedraId/pagos', requireDocente, async (req, res) => {
    const { alumnoId, catedraId } = req.params;
    const docenteId = req.docente.docenteId;

    try {
      // 1. Verificar que la cátedra pertenezca al docente
      const catedra = await prisma.catedra.findFirst({
        where: {
          id: parseInt(catedraId),
          docenteId: docenteId,
        },
      });

      if (!catedra) {
        return res.status(404).json({ error: 'Cátedra no encontrada o acceso denegado.' });
      }

      // 2. Verificar que el alumno esté inscrito en la cátedra
      const catedraAlumno = await prisma.catedraAlumno.findUnique({
        where: {
          catedraId_alumnoId: {
            catedraId: parseInt(catedraId),
            alumnoId: parseInt(alumnoId),
          },
        },
        select: { id: true }, // Solo necesitamos el ID de CatedraAlumno
      });

      if (!catedraAlumno) {
        return res.status(404).json({ error: 'El alumno no está inscrito en esta cátedra.' });
      }

      const pagos = await prisma.pago.findMany({
        where: {
          catedraAlumnoId: catedraAlumno.id,
        },
        include: {
          confirmado_por: {
            select: { nombre: true, apellido: true },
          },
        },
        orderBy: {
          fecha_pago: 'desc',
        },
      });

      res.status(200).json(pagos);
    } catch (error) {
      console.error('Error al obtener historial de pagos del alumno:', error);
      res.status(500).json({ error: 'Error al obtener el historial de pagos.', details: error.message });
    }
  });

  return router;
};
